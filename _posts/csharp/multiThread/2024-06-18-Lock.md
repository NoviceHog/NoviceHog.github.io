---
layout: single
title:  "[C#] Lock 구현"
categories: 
    - C Sharp
tag: [c#, multiThread]
published: true

author_profile: true # 옆에뜨는 프로파일

date: 2024-06-18
last_modified_at: 2024-06-18
---
<!-- 
{: .notice--warning} // 알림 강조
{: .notice--success} // 초록색 강조
{: .notice--danger } // 초록색 강조
{: .notice--info}
{: .notice--primary}
{: .notice}

{: .H1-font}         // 제목 색
<span style="color:Skyblue"> 색 넣기 </span>
<br/> 한줄 내리기
 -->
이 글은 Rookiss님의  **[C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버**를 보고 헷갈리는 부분 위주로 정리한 글입니다. 틀리거나 부족한 부분이 있을 수 있습니다.
{: .notice--warning}

## Lock
Lock이란 공유 자원에 대한 동시 접근을 제어하는 데 사용되는 기술이다. 보통 멀티 쓰레드 환경에서 `작업의 원자성을 보장하기 위해 Lock을 이용`한다.<br>

만약 어떠한 어느 한 쓰레드에 의해 공유 자원에 대해 Lock이 걸렸고, 다른 쓰레드가 공유 자원에 접근하고자 할 때 어떤 식으로 대처할지에 따라 여러 종류로 나눌 수 있다.

### SpinLock
Lock의 구현 이론중 하나인 SpinLock은 다른 쓰레드가 공유 자원에 Lock을 걸고 있을 때 `끝날 때 까지 계속 기다리는 방법`으로 구현된다.

spinlock의 구현은 다음과 같다. 중요한 점은 멀티쓰레드 환경이기 떄문에 공유자원인 `_locked 변수를 바꾸는 작업 또한 원자성이 보장`되어야 한다. 그렇기 때문에
`Interlocked 클래스를 이용`한다. <br>
코드의 흐름은 Acquire()함수가 lock에 접근을 시도하여 이미 잠긴 상태라면 while문으로 끝날 때까지 무한정 대기, 열린 상태라면 해당 쓰레드가 사용중이기에 _locked를 잠김 상태로 전환한다.<br>
사용이 끝나면 Release()함수로 다른 쓰레드가 접근할 수 있도록 열림 상태로 전환한다.

```cs
class SpinLock
{
    volatile int _locked = 0; // 0은 열려있는 상태, 1은 잠김 상태
    public void Acquire()
    {
        while (true)
        {
            // CAS
            // 비교하여 0이 맞다면 1로 바꾼다, 이전 값을 반환한다.
            if (Interlocked.CompareExchange(ref _locked, 1, 0) == 0)
                // 열림 상태일 경우 루프를 빠져나옴
                break;
        }
    }

    public void Release()
    {
        // 열림
        _locked = 0;
    }
}
internal class Program
{
    static int _num = 0;
    static SpinLock _lock = new SpinLock();

    static void Thread_1()
    {
        for (int i = 0; i < 100000; i++)
        {
            // lock 사용 시도 1. 이미 잠김 상태라면 대기 2. 열림 상태리면 바로 사용
            _lock.Acquire();
            _num++;
            // 사용 끝 
            _lock.Release();
        }
    }

    static void Thread_2()
    {
        for (int i = 0; i < 100000; i++)
        {
            _lock.Acquire();
            _num--;
            _lock.Release();
        }
    }

    static void Main(string[] args)
    {
        Task t1 = new Task(Thread_1);
        Task t2 = new Task(Thread_2);
        t1.Start();
        t2.Start();

        Task.WaitAll(t1, t2);

        Console.WriteLine(_num);
    }
}
```
