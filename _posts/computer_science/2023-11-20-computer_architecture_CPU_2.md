---
layout: single
title:  "[컴퓨터 구조] 빠른 CPU 위한 설계"
categories: 
    - cs
tag: [cs, computer_architecture]
published: true

author_profile: true # 옆에뜨는 프로파일

date: 2023-11-20
last_modified_at: 2023-11-20
---

이 글은 패스트캠퍼스의 **현실 세상의 컴퓨터공학 지식 with 30가지 실무 시나리오 초격차 패키지 Online.**를 보고 공부한 내용을 정리한 글입니다.
{: .notice--warning}

# CPU의 성능 향상
CPU의 성능 향상을 위해 접근해볼 방법은 두 가지가 있다.

하나는 하드웨어적인 접근 방법, 나머지는 소프트웨어적 접근 방법이다.

## CPU 향상을 위한 하드웨어적 접근
여기서 말할 CPU 항샹을 위한 하드웨어적 접근은 3가지가 있다.

- 클럭 속도 
- 멀티 코어
- 멀티 스레드

### 클럭 속도
`클럭 신호`는 부품을 일사분란하게 움직일 수 있게 하는 `시간 단위`이다.<br>
그러므로 클럭의 주기가 빠르다면, 즉 `클럭속도가(Hz)가 빠르다면` 좋은 CPU 성능을 가진다고 볼 수 있다.

물론 클럭 속도가 매우 높다고 해서 성능이 매우 좋아지지는 않는다.(발열 문제 때문)

### 멀티 코어
또 다른 성능 향상을 위한 방법은 무엇이 있냐 하면 `코어(Core)수`를 늘리는 것이다. `(멀티 코어 프로세서)`<br>
오늘날의 대부분의 컴퓨터는 멀티 코어를 지원하고 있다.

코어 : CPU 내에서 인출, 해석, 실행을 하는 부품을 묶는 단위
{: .notice--warning}

### 멀티 스레드
멀티 스레드에 앞서 스레드라는 용어는 혼용되는 경우가 많다. 그러므로 `CPU 관점`에서 보는 하드웨어적 스레드의 개념과
`운영체제 관점`에서 보는 소프트웨어적 스레드 두 가지로 경우가 있음을 알아야 한다.

- 하드웨어적 스레드 : `하나의 코어`가 `동시에 처리하는 명령어 단위`
- 소프트웨어 스레드 : 하나의 프로그램을 독립적으로 실행하는 단위


멀티 스레드 CPU는 `여러 개의 하드웨어적 스레드`로 `한 코어로 여러 명령어를 실행 가능`한 CPU를 말한다.

메모리의 기준에선 멀티 코어와 멀티 스레드를 `구분하기 힘들다.` 그렇기 때문에
두 가지를 합쳐서 `논리 프로세서`라고 표현하며 이것을 성능의 척도로 한다.

<img width="209" alt="image" src="https://github.com/novicehog/comments/assets/131991619/4a6c8842-4f81-4a89-9928-9aed0c740506">

## CPU 향상을 위한 소프트웨어적 접근
단순히 하드웨어적인, 즉 물리적인 부품 말고 `소프트웨어적인 접근으로 CPU의 성능 향상`을 기대해 볼 수 있는 방법은
`명령어 병렬 처리 기법(파이프라이닝)`이 있다.

### 명령어 파이프라이닝
우선 명령어가 처리되는 과정을 보면 크게 4가지로 나눌 수 있다.
1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 명령어 저장

위 단계들은 `서로 겹치지만 않는`다면 `한꺼번에 실행`할 수 있다.

명령어 파이프라인O

![image](https://github.com/novicehog/comments/assets/131991619/fa9fc49c-e816-475b-b8ca-626a4aca1fd8)

<br>

명령어 파이프라인X

![image](https://github.com/novicehog/comments/assets/131991619/b255facc-d388-45c7-ac1e-25cb3fe72468)


### 명령어 파이프라이닝 실패
명령어 파이프라이닝은 그림으로만 보더라도 확실히 성능 향상을 기대해 볼 수 있다.<br>
하지만 이 기법이 항상 적용이 가능한 것은 아닌데, 다음은 명령어 파이프라인이 실패하는 경우들이다.

1. 데이터 위험 (data hazard)
2. 제어 위험 (control hazard)
3. 구조적 위험 (structural hazard)

#### 데이터 위험 (data hazard)
데이터 위험은 명령어간의 `의존성에 의해 발생`하는 문제이다.

1. `데이터가 쓰여진 직후` `그 데이터를 읽어`들이는 경우(Read After Write)<br>
  명령어 1 : R1 <- R2 + R3
  명령어 2 : R4 <- R1 + R5
2. `데이터를쓴 직후` 그 데이터에` 새 내용을 쓰는 경우`(Write After Write)<br>
  명령어 1 : R1 <- R2 + R3
  명령어 2 : R1 <- R4 + R5
3. 데이터를 읽어들인 직후 그 데이터에 새 내용을 쓰는 경우(Write After Read)<br>
  명령어 1 : R3 <- R2 + R1
  명령어 2 : R1 <- R4 + R5


#### 제어 위험 (control hazard)
`프로그램 카운터`에 `갑작스러운 변화`에 의해 발생(분기)한다

순차적으로 명령어를 인출, 해석을 하는데 먼저 인출, 해석, 실행된 명령어가 <br>
`프로그램 카운터의 값을 갑작스럽게 분기`시킬 때 발생

<img width="304" alt="image" src="https://github.com/novicehog/comments/assets/131991619/a09701b5-21fe-4fa2-b57b-556c1ef54155">

이러한 분기 문제는 `분기 예측(branch prediction)`이라는 기술을 통해 분기할 주소를 예측해서 미리 인출하는 방법이 있다.


#### 구조적 위험 (structural hazard)
서로 다른 명령어가 `같은 자원을 사용`하려 할 경우 발생

![image](https://github.com/novicehog/comments/assets/131991619/fa1577f5-1c29-4198-b399-fa89f4ab2da8)

이러한 구조적 위험은 하드웨어적 설계에 크게 좌우되며 고성능의 하드웨어일수록 구조적 위험의 경향이 덜 발생한다.



### 파이프라이닝에 영향을 주는 CPU 구조
CPU의 구조에 따라 파이프라이닝 활용에 영향을 주기도 한다.

흔히 `ISA (Instruction Set Architecture)`라고 하는 CPU가 사용하는 `명령어의 집합`이 영향을 주며
ISA는 `CISC와 RISC`로 크게 두가지로 나눌 수 있다.

CISC : Complex Instruction Set Computer (Inter x86 CPU)
RISC : Reduced Instruction Set Computer (ARM CPU)


#### CISC
- 복잡하고 다양한 기능의 명령어 제공(명령어 하나가 많은 역할을 함)
- 다양한 주소 지정 방식 제공
- 적은 명령어 수로 명령어 실행 가능

CISC는 명령어 하나하나의 실행이 `일정한 시간을 가지지 않는다`. 그러므로 `명령어 파이프라이닝에 불리`하다.

![image](https://github.com/novicehog/comments/assets/131991619/2f16d420-b65d-488d-a27a-1716d5d3730d)

#### RISC
- `짧고 규격화`된 명령어 -> `명령어 파이프라이닝에 유리함`
- 적은 수의 명령어 제공
- `메모리 접근 최소화`(레지스터 활용)
- CISC에 비해 더 많은 명령어로 실행 -> 컴파일러 역할이 중요

![image](https://github.com/novicehog/comments/assets/131991619/90142b2e-f3dc-43ee-9aa9-571b27aaa6b4)